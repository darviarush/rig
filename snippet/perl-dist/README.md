# NAME

{{pkg}} - 

# VERSION

Version 1.2

# SYNOPSIS

    use {{pkg}};
    
    ${{name}} = {{pkg}}->new(  );

# DESCRIPTION

Модуль {{pkg}} используется для .

Это данные, которые имеют ограниченный срок хранения, но при этом не должны
удаляться из-за нехватки памяти или по каким-то другим "случайным" причинам.

Модуль оперирует данными в формате ключ/значение:

- Ключ состоит из двух частей - тип и собственно ключ
- Тип - это неймспейс для раздельного хранения различных сущностей (сессии, корзины, и.т.п.)
- Ключи уникальны в пределах типа
- В данных хранится сериализованное значение перловой структуры
- Время жизни ключа задается в секундах от текущего времени, в хранилище записывается время окончания жизни в unixtime

# SUBROUTINES/METHODS

## new

    $hsi = {{pkg}}->new( %params );

Конструктор объекта, содержащего подключение к хранилищу.

Принимает параметры:

- **host**

    Адрес хранилища. Доменное имя или IP.

- **port**

    Порт хранилища.

    Необязательный параметр. Значений по умолчанию - 3301 (стандартный порт Тарантула).

- **space**

    Название таблицы, в которой хранятся данные. Строка.

    Таблицы (спейсы в терминологии Тарантула) и их свойства задаются в конфигурации 
    хранилища.

- **connect\_timeout**

    Таймаут подключения. Секунды.

    Значение по умолчанию - 1.

- **request\_timeout**

    Таймаут запроса. Секунды.

    Значение по умолчанию - 1.

## set

    my $record = $hsi->set( $type, $key, $data, $ttl );

Записать данные в хранилище.

Принимает параметры:

- **$type**

    Тип временных данных. Строка.

    Произвольное название типа данных. Например, 'session', 'cart', 'page' и.т.п.

- **$key**

    Ключ. Строка.

    Произвольное (но уникальное в пределах типа) название ключа. Например, '1234', 'key1/25' и.т.п.

- **$data**

    Данные. Допускается указывать скаляр или ссылку на структуру (т.е. ссылку на
    хеш или на массив, внутри которых тоже скаляры или ссылки на структуры).

    Если данные являются объектом или если в структуре есть ссылки на объекты, то
    такие данные нужно предварительно сериализовать (например, через Storable).

- **$ttl**

    Время жизни данных в хранилище. Число.

    Время жизни задается в секундах. В хранилище время жизни будет прибавлено к
    текущему времени и записано как время устаревания - unixtime, после которого
    данные будет удалены.

В случае успешного выполнения метод возвращает ссылку на массив, соответствующий
тем данным и метаданным, которые были записаны в хранилище.

    [
        $type,    # Тип
        $key,     # Ключ
        $data,    # Данные
        $expires, # Время устаревания (время на момент записи + $ttl)
    ]

В случае ошибки метод выбрасывает исключение.

## get

    my $data= $hsi->get( $type, $key[, $builder, $ttl] );

Прочитать данные из хранилища.

Принимает параметры:

- **$type**

    Тип данных. Строка.

    Произвольное название типа данных. Например, 'session', 'cart', 'page' и.т.п.

- **$key**

    Ключ. Строка.

    Произвольное (но уникальное в пределах типа) название ключа. Например, '1234',
    'key1/25' и.т.п.

- **$builder**

    Конструктор данных. Ссылка на функцию.

    Если в хранилище не оказалось запрашиваемых данных то возможны два варианта:

    1) Если конструктор данных не был задан - метод возвратит неопределенное значение.

    2) Если конструктор данных был задан - он будет вызван и возвращенные из конструктора
    данные будут записаны в хранилище.

    Конструктор данных должен возвращать одно значение. Если конструктор возвратит
    список, то будет использовано только первое значение из спика, все прочие значения 
    будут отброшены.

- **$ttl**

    Время жизни данных в хранилище. Число.

    Время жизни задется в секундах. В хранилище время жизни будет прибавлено к
    текущему времени и записано как время устаревания - unixtime, после которого
    данные будет удалены.

    В методе `get` этот параметр используется только совместно с конструктором данных.

В случае успешного выполнения метод возвращает данные в том же виде, в котором
они были ранее переданы в метод `set` (или возвращены конструктором данных).

Данные всегда возвращаются в юникоде (wide). Если это были сериализованные данные,
то перед десериализацией их нужно привести к байтам (выполнить utf8::encode).

В случае ошибки метод выбрасывает исключение.

## remove

    my $is_success = $hsi->remove( $type, $key );

Удалить данные из хранилища.

Принимает параметры:

- **$type**

    Тип данных. Строка.

    Произвольное название типа данных. Например, 'session', 'cart', 'page' и.т.п.

- **$key**

    Ключ. Строка.

    Произвольное (но уникальное в пределах типа) название ключа. Например, '1234', 'key1/25' и.т.п.

В случае успешного выполнения метод возвращает истинный ноль.

В случае ошибки метод выбрасывает исключение.

## refresh

    my $record = $hsi->refresh( $type, $key, $ttl );

Обновить время устаревания данных в хранилище.

Принимает параметры:

- **$type**

    Тип данных. Строка.

    Произвольное название типа данных. Например, 'session', 'cart', 'page' и.т.п.

- **$key**

    Ключ. Строка.

    Произвольное (но уникальное в пределах типа) название ключа. Например, '1234', 'key1/25' и.т.п.

- **$ttl**

    Время жизни данных в хранилище. Число.

    Время жизни задется в секундах. В хранилище время жизни будет прибавлено к
    текущему времени и записано как время устаревания - unixtime, после которого
    данные будет удалены.

В случае успешного выполнения метод возвращает ссылку на массив, соответствующий
тем данным и метаданным, которые были записаны в хранилище (аналогично методу set).

В случае ошибки метод выбрасывает исключение.

Внимание! Если ключ отсутствует, то попытка его обновить вызовет ошибку и, соответственно, исключение.

## check

    my $bool = $hsi->check( $type, $key );

Проверить наличие ключа в хранилище.

Принимает параметры:

- **$type**

    Тип данных. Строка.

    Произвольное название типа данных. Например, 'session', 'cart', 'page' и.т.п.

- **$key**

    Ключ. Строка.

    Произвольное (но уникальное в пределах типа) название ключа. Например, '1234', 'key1/25' и.т.п.

В случае успешного выполнения метод возвращает количество найденных ключей.
Поскольку ключи уникальны, то по факту всегда возвращается 1 или 0.

В случае ошибки метод выбрасывает исключение.

# AUTHOR

Yaroslav O. Kosmina <darviarush@mail.ru>

# LICENSE

⚖ **GPLv3**
